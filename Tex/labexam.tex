\chapterimage{../Pictures/exam.jpg}
\chapter{Lab Tests}

\input{examconditions}
\input{howtosubmit}
\input{codestyle}

\newpage
\nsection{Anagrams}
\subsection*{Part 1 (60\%)}

An anagram is a rearrangement of a word, using all the letters.
Two words are said to be anagrams if they have the same characters,
but in a different order.
For instance the words `parsley', `players' and `replays'
are all anagrams of each other.

Since you need to rearrange the words, two identical words, by definition, are not anagrams.

Using the following template, fill in the function \verb^anagram()^,
so that the program runs successfully~:
\begin{verbatim}
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

int anagram(char s1[], char s2[]);

int main(void)
{
   assert(anagram("elvis", "lives") == 1);
   assert(anagram("dreads", "sadder") == 1);
   assert(anagram("replays", "parsley") == 1);
   assert(anagram("listen", "silent") == 1);
   assert(anagram("orchestra", "carthorse") == 1);

   /* Two identical words are not anagrams */
   assert(anagram("elvis", "elvis") == 0);

   assert(anagram("neill", "neil") == 0);
   assert(anagram("neil", "neill") == 0);
   assert(anagram("horse", "short") == 0);

   return 0;
}

int anagram(char s1[], char s2[])
{


}
\end{verbatim} 

Obviously, your program will need to run for other, unseen but similar, test cases. 

\subsection*{Part 2 (40\%)}

A deranged anagram has two words with the same characters, but the same
character does not appear in the same position.

The words `elvis' and `lives' are not a derangement since the `s' is
in the same position in both words.
However, `dreads' and `sadder' are, since no letter appears in the
same position between the two words.

Extend the program above so that the following assertions, inside \verb^main()^
are correct:
\begin{verbatim}
   assert(derange("elvis", "lives") == 0);
   assert(derange("dreads", "sadder") == 1);
   assert(derange("replays", "parsley") == 1);
   assert(derange("listen", "silent") == 0);
   assert(derange("orchestra", "carthorse") == 1);
\end{verbatim}



\nsection{Isograms}
\subsection*{Part 1 (60\%)}

An isogram is a word that has no repeating letters. For instance the words `graciously', `disgraceful' and
`productively' are all isograms. However, the word `dazzlingly' is not (it contains the letters `z' and `l'
twice).

Using the following template, fill in the function \verb^isogram()^, so that the program runs
successfully~:
\begin{verbatim}
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

int isogram(char *s);

int main(void)
{
   assert(isogram("programming") == 0);
   assert(isogram("housewarmings") == 0);
   assert(isogram("abductions") == 1);
   assert(isogram("housewarming") == 1);
   assert(isogram("hydromagnetics") == 1);
   assert(isogram("uncopyrightable") == 1);
   return 0;
}

int isogram(char *s)
{


}
\end{verbatim} 

\subsection*{Part 2 (40\%)}
Using the \verb^isogram()^ function written above, write a program which finds the {\it longest} isogram in a
file of words. The name of the file is provided via the use of \verb^argv^.
On success, the program simply outputs the longest word and its length, nothing else. For
example~:
\begin{verbatim}
$ ./parttwo eowl_shuffle.txt
waveringly (10)
\end{verbatim}

The file may contain many isograms of (equal) longest length. In this case,
outputting any one of them will do. 

\nsection{Mutating Boards}
\subsection*{Part 1 (60\%)}

Write a {\bf function} that fills up a square board, randomly,
with an integer $0 \dots 9$. Use a:\\
\verb^#define N 20^\\
to define the size of the board.  Write another function to print the board.
The board may look something like:

{\small
\begin{verbatim}
36753562912709360626
18792023759228973612
93194784503610632061
55476569374525474430
78688431492068926649
50487172722610615949
09177115977673656394
81293908850963856115
98481030444476317596
21785741859753883189
64333860488897764303
09254059469224775481
28936802105110850646
25862847240629908131
10340391969338056640
04626756987282996027
61321599149107587048
04296104222055290283
80409196254499360502
94351743146942264128
\end{verbatim}
}

Write a
function to `mutate' the board. Mutating is done like this:
\begin{itemize}
\item Choose two random locations which are {\bf horizontally adjacent} (next to each other left-right).
\item Swap these two numbers on the board if the left one is greater than the right one, numerically.
\item Choose two random locations which are {\bf vertically adjacent} (next to each other up-down).
\item Swap these two numbers on the board if the upper one is greater than the lower one, numerically.
\item Repeat the above steps (N*N*N) times.
\end{itemize}

Now print out the board. It should look something like~:
{\small
\begin{verbatim}
00000000000001111224
00000001111111233456
00000111112222244456
00001122222333445666
00112222223333555667
01112223333334556678
01112223334445556779
01122333344445556789
01223334444455666789
01223344445556666789
01223344455666667789
01224444456666777889
01234455566677777889
01234555666677788899
01234555666778888899
12234566677788888999
12345567777888889999
12445677788888899999
34446678889999999999
46678899999999999999
\end{verbatim}
}

Ensure that if you change the size of your array, by changing your \verb^#define^
that the program still operates correctly.

\subsection*{Part 2 (40\%)}
Adapt the code above, so that the algorithm is:
\begin{itemize}
\item Choose two numbers at random locations on the board.
\item Check that of these two numbers, the one closest to the centre of the array
is numerically less than the number furthest away from the centre. If not, swap them.
\item Repeat the above steps (N*N*N*N) times.
\end{itemize}

Once again randomise the array initially, and ensure that after changing your \verb^#define^
the program still works correctly.

When $N=21$, the array may look something like:
{\samepage
{\small
\begin{verbatim}
999998887777788899999
999987666656666788999
998876554444555678899
998665443333444566889
987654333222233456789
876543322112223345678
865443211111112334568
765432111000011234568
765422100000001234567
764321100000001223467
764321100000001123457
764322100000001223467
765422100000001224567
865432110000011234568
865432211111122334568
876543322212223345678
987654333222233456789
988665444333344567889
998876555444455678899
999887666656666789999
999998887777788899999
\end{verbatim}
}
}
